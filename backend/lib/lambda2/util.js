"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEmailFromAccessToken = exports.generateResponse = exports.getExpireDate = exports.getResponseTemplate = void 0;
const aws_sdk_1 = require("aws-sdk");
const rest_1 = require("./federation/rest");
const provider = new aws_sdk_1.CognitoIdentityServiceProvider();
const getResponseTemplate = () => {
    var response = {
        statusCode: 200,
        headers: {
            "Access-Control-Allow-Headers": "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token",
            "Access-Control-Allow-Methods": "*",
            "Access-Control-Allow-Origin": "*",
        },
        body: "{}",
        isBase64Encoded: false,
    };
    return response;
};
exports.getResponseTemplate = getResponseTemplate;
const getExpireDate = () => {
    return Math.floor(Date.now() / 1000) + 60 * 60 * 24;
};
exports.getExpireDate = getExpireDate;
const generateResponse = (body) => {
    var response = {
        statusCode: 200,
        headers: {
            "Access-Control-Allow-Headers": "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token",
            "Access-Control-Allow-Methods": "*",
            "Access-Control-Allow-Origin": "*",
        },
        body: JSON.stringify(body),
        isBase64Encoded: false,
    };
    return response;
};
exports.generateResponse = generateResponse;
const getEmailFromAccessToken = async (accessToken) => {
    const tokens = accessToken.split(",");
    if (tokens.length === 1) {
        const p = new Promise((resolve, reject) => {
            provider.getUser({ AccessToken: tokens[0] }, (err, data) => {
                // console.log(err);
                if (err) {
                    console.log("[getEmailFromAccessToken] token is not cognito accessToken");
                    reject("[getEmailFromAccessToken] token is not cognito accessToken");
                }
                console.log(data);
                resolve(data);
            });
        });
        const userData = await p;
        let email;
        let foundEmail = false;
        for (let i = 0; i < userData.UserAttributes.length; i++) {
            const att = userData.UserAttributes[i];
            if (att["Name"] == "email") {
                email = att["Value"];
                foundEmail = true;
            }
        }
        if (foundEmail) {
            return email;
        }
        else {
            console.log("email not found");
            throw "email not found";
        }
    }
    else if (tokens.length === 2) {
        if (tokens[0] === "slack") {
            const getUSerInformationResult = await (0, rest_1.getUserInformation)({
                restApiBaseURL: "https://slack-chime-connect.herokuapp.com/",
                token: tokens[1],
            });
            if (getUSerInformationResult.isFailure()) {
                throw "invalid token!! fail to fetch";
            }
            console.log(getUSerInformationResult.value);
            return getUSerInformationResult.value.userId;
        }
        else {
            console.log(`unknown provider ${tokens[0]}`);
            throw `unknown provider ${tokens[0]}`;
        }
    }
    else {
        console.log("this token format is not supported");
        throw "this token format is not supported";
    }
};
exports.getEmailFromAccessToken = getEmailFromAccessToken;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEscUNBQXlEO0FBRXpELDRDQUF1RDtBQUV2RCxNQUFNLFFBQVEsR0FBRyxJQUFJLHdDQUE4QixFQUFFLENBQUM7QUFFL0MsTUFBTSxtQkFBbUIsR0FBRyxHQUFHLEVBQUU7SUFDcEMsSUFBSSxRQUFRLEdBQUc7UUFDWCxVQUFVLEVBQUUsR0FBRztRQUNmLE9BQU8sRUFBRTtZQUNMLDhCQUE4QixFQUFFLHNFQUFzRTtZQUN0Ryw4QkFBOEIsRUFBRSxHQUFHO1lBQ25DLDZCQUE2QixFQUFFLEdBQUc7U0FDckM7UUFDRCxJQUFJLEVBQUUsSUFBSTtRQUNWLGVBQWUsRUFBRSxLQUFLO0tBQ3pCLENBQUM7SUFDRixPQUFPLFFBQVEsQ0FBQztBQUNwQixDQUFDLENBQUM7QUFaVyxRQUFBLG1CQUFtQix1QkFZOUI7QUFFSyxNQUFNLGFBQWEsR0FBRyxHQUFHLEVBQUU7SUFDOUIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUN4RCxDQUFDLENBQUM7QUFGVyxRQUFBLGFBQWEsaUJBRXhCO0FBRUssTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLElBQXNCLEVBQUUsRUFBRTtJQUN2RCxJQUFJLFFBQVEsR0FBRztRQUNYLFVBQVUsRUFBRSxHQUFHO1FBQ2YsT0FBTyxFQUFFO1lBQ0wsOEJBQThCLEVBQUUsc0VBQXNFO1lBQ3RHLDhCQUE4QixFQUFFLEdBQUc7WUFDbkMsNkJBQTZCLEVBQUUsR0FBRztTQUNyQztRQUNELElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQztRQUMxQixlQUFlLEVBQUUsS0FBSztLQUN6QixDQUFDO0lBQ0YsT0FBTyxRQUFRLENBQUM7QUFDcEIsQ0FBQyxDQUFDO0FBWlcsUUFBQSxnQkFBZ0Isb0JBWTNCO0FBRUssTUFBTSx1QkFBdUIsR0FBRyxLQUFLLEVBQUUsV0FBbUIsRUFBRSxFQUFFO0lBQ2pFLE1BQU0sTUFBTSxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEMsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUNyQixNQUFNLENBQUMsR0FBRyxJQUFJLE9BQU8sQ0FBaUQsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFDdEYsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRTtnQkFDdkQsb0JBQW9CO2dCQUNwQixJQUFJLEdBQUcsRUFBRTtvQkFDTCxPQUFPLENBQUMsR0FBRyxDQUFDLDREQUE0RCxDQUFDLENBQUM7b0JBQzFFLE1BQU0sQ0FBQyw0REFBNEQsQ0FBQyxDQUFDO2lCQUN4RTtnQkFDRCxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNsQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDbEIsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztRQUNILE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxDQUFDO1FBQ3pCLElBQUksS0FBSyxDQUFDO1FBQ1YsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ3ZCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNyRCxNQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZDLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLE9BQU8sRUFBRTtnQkFDeEIsS0FBSyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDckIsVUFBVSxHQUFHLElBQUksQ0FBQzthQUNyQjtTQUNKO1FBQ0QsSUFBSSxVQUFVLEVBQUU7WUFDWixPQUFPLEtBQUssQ0FBQztTQUNoQjthQUFNO1lBQ0gsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1lBQy9CLE1BQU0saUJBQWlCLENBQUM7U0FDM0I7S0FDSjtTQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDNUIsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssT0FBTyxFQUFFO1lBQ3ZCLE1BQU0sd0JBQXdCLEdBQUcsTUFBTSxJQUFBLHlCQUFrQixFQUFDO2dCQUN0RCxjQUFjLEVBQUUsNENBQTRDO2dCQUM1RCxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQzthQUNuQixDQUFDLENBQUM7WUFDSCxJQUFJLHdCQUF3QixDQUFDLFNBQVMsRUFBRSxFQUFFO2dCQUN0QyxNQUFNLCtCQUErQixDQUFDO2FBQ3pDO1lBQ0QsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM1QyxPQUFPLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7U0FDaEQ7YUFBTTtZQUNILE9BQU8sQ0FBQyxHQUFHLENBQUMsb0JBQW9CLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDN0MsTUFBTSxvQkFBb0IsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7U0FDekM7S0FDSjtTQUFNO1FBQ0gsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO1FBQ2xELE1BQU0sb0NBQW9DLENBQUM7S0FDOUM7QUFDTCxDQUFDLENBQUM7QUFqRFcsUUFBQSx1QkFBdUIsMkJBaURsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvZ25pdG9JZGVudGl0eVNlcnZpY2VQcm92aWRlciB9IGZyb20gXCJhd3Mtc2RrXCI7XG5pbXBvcnQgeyBIVFRQUmVzcG9uc2VCb2R5IH0gZnJvbSBcIi4vaHR0cF9yZXF1ZXN0XCI7XG5pbXBvcnQgeyBnZXRVc2VySW5mb3JtYXRpb24gfSBmcm9tIFwiLi9mZWRlcmF0aW9uL3Jlc3RcIjtcblxuY29uc3QgcHJvdmlkZXIgPSBuZXcgQ29nbml0b0lkZW50aXR5U2VydmljZVByb3ZpZGVyKCk7XG5cbmV4cG9ydCBjb25zdCBnZXRSZXNwb25zZVRlbXBsYXRlID0gKCkgPT4ge1xuICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnNcIjogXCJDb250ZW50LVR5cGUsWC1BbXotRGF0ZSxBdXRob3JpemF0aW9uLFgtQXBpLUtleSxYLUFtei1TZWN1cml0eS1Ub2tlblwiLFxuICAgICAgICAgICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzXCI6IFwiKlwiLFxuICAgICAgICAgICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIjogXCIqXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IFwie31cIixcbiAgICAgICAgaXNCYXNlNjRFbmNvZGVkOiBmYWxzZSxcbiAgICB9O1xuICAgIHJldHVybiByZXNwb25zZTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRFeHBpcmVEYXRlID0gKCkgPT4ge1xuICAgIHJldHVybiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDYwICogNjAgKiAyNDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVJlc3BvbnNlID0gKGJvZHk6IEhUVFBSZXNwb25zZUJvZHkpID0+IHtcbiAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzXCI6IFwiQ29udGVudC1UeXBlLFgtQW16LURhdGUsQXV0aG9yaXphdGlvbixYLUFwaS1LZXksWC1BbXotU2VjdXJpdHktVG9rZW5cIixcbiAgICAgICAgICAgIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctTWV0aG9kc1wiOiBcIipcIixcbiAgICAgICAgICAgIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCI6IFwiKlwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgaXNCYXNlNjRFbmNvZGVkOiBmYWxzZSxcbiAgICB9O1xuICAgIHJldHVybiByZXNwb25zZTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRFbWFpbEZyb21BY2Nlc3NUb2tlbiA9IGFzeW5jIChhY2Nlc3NUb2tlbjogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgdG9rZW5zID0gYWNjZXNzVG9rZW4uc3BsaXQoXCIsXCIpO1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZTxDb2duaXRvSWRlbnRpdHlTZXJ2aWNlUHJvdmlkZXIuR2V0VXNlclJlc3BvbnNlPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBwcm92aWRlci5nZXRVc2VyKHsgQWNjZXNzVG9rZW46IHRva2Vuc1swXSB9LCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW2dldEVtYWlsRnJvbUFjY2Vzc1Rva2VuXSB0b2tlbiBpcyBub3QgY29nbml0byBhY2Nlc3NUb2tlblwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiW2dldEVtYWlsRnJvbUFjY2Vzc1Rva2VuXSB0b2tlbiBpcyBub3QgY29nbml0byBhY2Nlc3NUb2tlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdXNlckRhdGEgPSBhd2FpdCBwO1xuICAgICAgICBsZXQgZW1haWw7XG4gICAgICAgIGxldCBmb3VuZEVtYWlsID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXNlckRhdGEuVXNlckF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dCA9IHVzZXJEYXRhLlVzZXJBdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgaWYgKGF0dFtcIk5hbWVcIl0gPT0gXCJlbWFpbFwiKSB7XG4gICAgICAgICAgICAgICAgZW1haWwgPSBhdHRbXCJWYWx1ZVwiXTtcbiAgICAgICAgICAgICAgICBmb3VuZEVtYWlsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRFbWFpbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVtYWlsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJlbWFpbCBub3QgZm91bmRcIik7XG4gICAgICAgICAgICB0aHJvdyBcImVtYWlsIG5vdCBmb3VuZFwiO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0b2tlbnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGlmICh0b2tlbnNbMF0gPT09IFwic2xhY2tcIikge1xuICAgICAgICAgICAgY29uc3QgZ2V0VVNlckluZm9ybWF0aW9uUmVzdWx0ID0gYXdhaXQgZ2V0VXNlckluZm9ybWF0aW9uKHtcbiAgICAgICAgICAgICAgICByZXN0QXBpQmFzZVVSTDogXCJodHRwczovL3NsYWNrLWNoaW1lLWNvbm5lY3QuaGVyb2t1YXBwLmNvbS9cIixcbiAgICAgICAgICAgICAgICB0b2tlbjogdG9rZW5zWzFdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZ2V0VVNlckluZm9ybWF0aW9uUmVzdWx0LmlzRmFpbHVyZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJpbnZhbGlkIHRva2VuISEgZmFpbCB0byBmZXRjaFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coZ2V0VVNlckluZm9ybWF0aW9uUmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRVU2VySW5mb3JtYXRpb25SZXN1bHQudmFsdWUudXNlcklkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHVua25vd24gcHJvdmlkZXIgJHt0b2tlbnNbMF19YCk7XG4gICAgICAgICAgICB0aHJvdyBgdW5rbm93biBwcm92aWRlciAke3Rva2Vuc1swXX1gO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJ0aGlzIHRva2VuIGZvcm1hdCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB0aHJvdyBcInRoaXMgdG9rZW4gZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWRcIjtcbiAgICB9XG59O1xuIl19